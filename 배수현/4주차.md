### 캐시가 없을 때

1. STAR.jpg에 대한 요청
2. 서버에서 star.jpg 리턴 1.1m
3. 일정 시간이 지난 후 STAR.jpg에 대한 재요청
4. 서버에서 star.jpg 리턴 1.1m
    1. 같은 요청이 또 들어오면 똑같이 헤더랑 바디부를 따로 만들어서 다시 내려줌

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운받아야 한다.
- → 느리고 비싸다

### 캐시 기본 동작

- 헤더에 캐시 설정을 넣어서 일정시간 동안 캐시를 유지해줌
- 캐시가 유효한 시간: `cache-control: max-age=60`
1. star.jpg에 대한 요청
2. 서버에서 star.jpg를 리턴 1.1m
3. 해당 응답 결과를 캐시에 저장
4. 새로 star.jpg에 대한 요청
    1. 캐시를 먼저 찾아본다
    2. 유효시간 내이면 캐시 안에서 쿠키를 찾아올 수 있음
    3. 굳이 네트워크가 아닌 브라우저 캐시에서 다운 받을 수 있다

**장점**

- 캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다
- 로딩 속도가 빠르다

**캐시 적용 - 캐시 시간 초과**

1. 캐시 시간이 초과되면 서버를 통해서 데이터를 다시 조회하고 캐시를 갱신함 (첫 응답과 같은 과정)
2. 네트워크 다운로드가 발생

→ 해결 메커니즘

<aside>
💡 검증 헤더와 조건부 요청

</aside>

### 캐시 시간 초과 - 검증 헤더 적용

서버에 데이터를 요청할 시 발생할 수 있는 두가지 경우

1. 서버에서 기존 데이터를 변경
2. 서버에서 기존 데이터를 변경하지 않음
    1. 저장해두었던 캐시 재사용 가능
    2. 클라 데이터와 서버의 데이터가 같다는 사실 확인 → 검증헤더

**검증헤더**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/784db47c-b5ea-4738-98d0-d2c6a31ed887/Untitled.png)

1. star.jpg에 대한 요청
2. 응답 결과를 서버에서 다운받아서 캐시에 저장 + 데이터 최종 수정일
3. 두번째 star.jpg에 대한 요청
    1. 브라우저 캐시에서 데이터 최종 수정일을 확인
    2. 해당 데이터를 서버에 요청과 함께 보냄
    3. 서버에서 데이터 최종 수정일과 캐시 데이터 수정일이 같으면 데이터가 수정된게 아니므로
    4. 304 not modified를 보냄
4. 브라우저 캐시에서 응답 결과를 재사용, 헤더 데이터 갱신

<aside>
💡 캐시+ 검증 헤더를 사용하면 네트워크 다운로드는 발생하지만 용량이 적은 헤더만 다운로드 하게 되므로 훨씬 효율적이다.

</aside>

### 검증 헤더와 조건부 요청

- 검증 헤더
    - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
    - last-modified, ETag
- 조건부 요청 헤더
    - 검증 헤더로 조건에 따른 분기
    - If-Modified-Since: Last-Modified 사용
    - If-None_match : ETag 사용
    

**ETag 사용 예시**

- ETag: “aaaaaaaaaaa”
- 같은 내용을 담은 파일이면 etag값이 같으므로 해당 기능을 사용하여 같은 데이터 여부를 확인한다
