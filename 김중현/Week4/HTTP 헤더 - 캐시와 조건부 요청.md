# Section 8. HTTP 헤더 - 캐시와 조건부 요청
## 캐시 기본 동작
### 캐시가 없을 때
- 데이터가 변경되지 않아도(똑같은 데이터를) 계속 네트워크를 통해 데이터를 다운로드 받아야 한다.
- 인터넷 네트워크는 pc의 메모리나 하드디스크에 비해 매우 느리고 비싸다.
- 사용자 입장에서는 브라우저 로딩 속도가 느리다.
<br>

### 캐시 적용
```
1. 첫 번째 요청 시 서버에서 데이터를 보낼 때 캐시가 유효한 시간을 포함해 보낸다. (Ex. cache-control: max-age=60)
2. 응답 결과를 유효한 시간 동안 캐시에 저장해둔다.
3. 두 번째 요청 시(캐시 유효 시간 내) 캐시에서 데이터를 꺼내 쓴다.
4. 세 번째 요청 시(캐시 유효 시간 초과) 서버에서 다시 똑같은 메시지를 내려준다. 이 때, 캐시를 덮어씌우면서 캐시가 초기화된다.
```
- 캐시 사용 시 캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빠르기 때문에 빠른 사용자 경험을 할 수 있다.
- 캐시 유효 시간이 초과되면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다.(네트워크 다운로드 재발생) <br>
→ 캐시 유효 시간이 지나면 똑같은 데이터를 또 서버에서 다시 다운로드 받아야 하는 것이 효율적이지 않아보인다!
<br>
<br>

## 검증 헤더와 조건부 요청
### 캐시 시간 초과
- 캐시 유효 시간이 초과해 서버에 다시 요청 시 다음 두 가지 상황이 가능
  1. 서버에서 기존 데이터를 변경하지 않은 경우
  2. 서버에서 기존 데이터를 변경한 경우
<br>

#### 1. 서버에서 기존 데이터를 변경하지 않은 경우
- 똑같은 데이터를 또 전송하는 대신에 저장해두었던 캐시를 재사용할 수 있다.
- 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요 <br>
→ **검증 헤더** 추가
<br>

```
1. 첫 번째 요청 시 서버에서 데이터에 검증 헤더를 추가해 내려보낸다.(Ex. Last-Modified: 2020-11-10T10:00:00)
2. 클라이언트는 응답 결과를 캐시에 저장하는데 Last-Modified 값을 함께 저장한다.
3. 캐시 유효 시간이 지난 후 두 번째 요청 시 요청 헤더에 if-modified-since 헤더 값에 캐시에서 가져온 Last-Modified 값을 써서 보낸다.
4. 서버에서는 해당 데이터의 최종 수정일을 확인해 요청의 if-modified-since 값과 비교해 판단할 수 있다.
  4-1. 최종 수정일이 같으면, 서버에서 내려줄 때 상태코드를 304 Not Modified로 하고 HTTP Body를 비워서 내려준다. (수정 사항이 없기 때문)
       클라이언트는 304 Not Modified를 보고 제사용해도 된다는 것을 인지한 후, cache-control 값을 갱신하고 캐시에서 데이터를 불러와 사용한다.
```
<br>

#### 정리
- 캐시 유효 시간이 초과하더라도 서버의 데이터가 갱신되지 않으면, `304 Not Modified`와 `헤더 메타 정보`만 응답하고 바디는 제외한다.
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신하고, 캐시에 저장되어 있는 데이터를 재활용한다.
- 결과적으로는 네트워크 다운로드가 발생하긴 하지만, 용량이 적은 헤더 정보만 다운로드 받게 된다.
